
.. _program_listing_file_include_CustomLibrary_SDL_Text.h:

Program Listing for File Text.h
===============================

|exhale_lsh| :ref:`Return to documentation for file <file_include_CustomLibrary_SDL_Text.h>` (``include/CustomLibrary/SDL/Text.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef _CTL_SDL2_Text_
   #define _CTL_SDL2_Text_
   
   #include <SDL2/SDL.h>
   #include <SDL2/SDL_ttf.h>
   
   #include "../BasicTypes.h"
   #include "../Error.h"
   
   #include "Texture.h"
   #include "Loader.h"
   
   #include <cassert>
   
   namespace ctl::sdl
   {
       // -----------------------------------------------------------------------------
       // Font
       // -----------------------------------------------------------------------------
   
       class Font
       {
           struct Unique_Deleter
           {
               void operator()(TTF_Font *f) { TTF_CloseFont(f); }
           };
   
       public:
           Font()        = default;
           Font(Font &&) = default;
           auto operator=(Font &&) -> Font & = default;
   
           Font(const Font &) noexcept = delete;
           auto operator=(const Font &) noexcept = delete;
   
           auto font() noexcept
           {
               assert(m_ptr && "Font is not loaded.");
               return m_ptr.get();
           }
   
           auto font(TTF_Font *f) noexcept { m_ptr.reset(f); }
   
           void style(int style) { TTF_SetFontStyle(font(), style); }
   
           auto style() { return TTF_GetFontStyle(font()); }
   
           auto hypo_size(const char *text)
           {
               mth::Dim<int> temp;
               TTF_SizeUTF8(font(), text, &temp.w, &temp.h);
               return temp;
           }
   
       private:
           std::unique_ptr<TTF_Font, Unique_Deleter> m_ptr;
       };
   
       template<template<typename> class... Ex>
       using EFont = typename MixBuilder<Font, Ex...>::type;
   
       // -----------------------------------------------------------------------------
       // Text
       // -----------------------------------------------------------------------------
   
       class Text : public Texture
       {
       public:
           using base = Texture;
   
           Text() = default;
   
           using Texture::Texture;
   
           auto text(SDL_Texture *t, const char *text)
           {
               this->texture(t);
               m_text = text;
           }
   
           [[nodiscard]] constexpr auto text() const noexcept -> const auto & { return m_text; }
   
       private:
           std::string m_text;
       };
   
       template<template<typename> class... Ex>
       using EText = typename MixBuilder<Text, Ex...>::type;
   
   } // namespace ctl::sdl
   
   #endif // !_CTL_SDL2_Text_
