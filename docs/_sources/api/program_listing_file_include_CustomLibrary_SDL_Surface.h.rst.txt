
.. _program_listing_file_include_CustomLibrary_SDL_Surface.h:

Program Listing for File Surface.h
==================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_CustomLibrary_SDL_Surface.h>` (``include/CustomLibrary/SDL/Surface.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <SDL2/SDL.h>
   
   #include "../Error.h"
   
   #include <memory>
   #include <cassert>
   #include <stdexcept>
   
   namespace ctl::sdl
   {
       class Surface
       {
           struct Unique_Destructor
           {
               void operator()(SDL_Surface *s) { SDL_FreeSurface(s); }
           };
   
       public:
           Surface() noexcept           = default;
           Surface(Surface &&) noexcept = default;
           auto operator=(Surface &&) noexcept -> Surface & = default;
   
           Surface(const Surface &) noexcept = delete;
           auto operator=(const Surface &) noexcept = delete;
   
           explicit Surface(SDL_Surface *s) noexcept
               : m_surface(s)
           {
           }
   
           [[nodiscard]] auto surface() const noexcept { return m_surface.get(); }
   
           auto surface(SDL_Surface *s) noexcept -> void { m_surface.reset(s); }
   
           auto color_key(Uint32 key, SDL_bool enabled = SDL_TRUE) -> void
           {
               const auto r = SDL_SetColorKey(m_surface.get(), enabled, key);
               ASSERT(r == 0, SDL_GetError());
           }
   
           auto resize(const int *const x, const int *const y) -> void
           {
               if (x == nullptr && y == nullptr)
                   return;
   
               SDL_Surface *temp = SDL_CreateRGBSurface(
                   0, x == nullptr ? static_cast<int>(static_cast<double>(*y) / m_surface->h * m_surface->w) : *x,
                   y == nullptr ? static_cast<int>(static_cast<double>(*x) / m_surface->w * m_surface->h) : *y,
                   m_surface->format->BitsPerPixel, m_surface->format->Rmask, m_surface->format->Gmask,
                   m_surface->format->Bmask, m_surface->format->Amask);
   
               SDL_BlitScaled(m_surface.get(), nullptr, temp, nullptr);
   
               m_surface.reset(temp);
           }
   
       private:
           std::unique_ptr<SDL_Surface, Unique_Destructor> m_surface;
       };
   
   } // namespace ctl::sdl
