
.. _program_listing_file_include_CustomLibrary_SDL_Animation.h:

Program Listing for File Animation.h
====================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_CustomLibrary_SDL_Animation.h>` (``include/CustomLibrary/SDL/Animation.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef _CTL_SDL2_ANIMATION_
   #define _CTL_SDL2_ANIMATION_
   
   #include <SDL2/SDL.h>
   
   #include "../BasicTypes.h"
   #include "../Timer.h"
   
   #include "Drawable.h"
   #include "Texture.h"
   #include "TypeTraits.h"
   
   #include <vector>
   
   // DEPRECATED
   
   namespace ctl::sdl
   {
       struct AniFrame
       {
           AniFrame(const mth::Rect<int, int> &r, const std::chrono::milliseconds &t)
               : shape(r)
               , step(t)
           {
           }
   
           mth::Rect<int, int> shape;
           std::chrono::milliseconds step;
       };
   
       template<typename T>
       concept animation_iter = std::same_as<typename std::iterator_traits<T>::value_type, AniFrame>;
   
       class Animation : public Texture
       {
       public:
           using base = Texture;
   
           using Texture::Texture;
   
           Animation() = default;
   
           template<typename... P>
           void emplace_back_frame(P &&... param)
           {
               m_frames.emplace_back(std::forward<P>(param)...);
               m_curr_frame = m_frames.begin();
           }
           void push_back_frame(const AniFrame &f)
           {
               m_frames.push_back(f);
               m_curr_frame = m_frames.begin();
           }
           template<animation_iter Iter>
           void assign_frames(Iter begin_frame, Iter end_frame)
           {
               m_frames.assign(begin_frame, end_frame);
               m_curr_frame = m_frames.begin();
           }
   
           void start_ani() noexcept { m_time.start(); }
           void pause_ani() noexcept { m_time.pause(); }
           void unpause_ani() noexcept { m_time.unpause(); }
           [[nodiscard]] auto is_ani_paused() const noexcept -> bool { return m_time.is_paused(); }
   
           auto blit_ani() noexcept -> const auto &
           {
               if (!m_time.is_paused() && !m_frames.empty())
               {
                   m_till_next += m_time.ticks();
   
                   while (m_till_next >= m_curr_frame->step)
                   {
                       m_till_next -= m_curr_frame->step;
                       ++m_curr_frame;
   
                       if (m_curr_frame == m_frames.end())
                           m_curr_frame = m_frames.begin();
                   }
   
                   m_time.start();
               }
   
               return m_curr_frame->shape;
           }
   
           [[nodiscard]] auto frames_size() const noexcept { return m_frames.size(); }
   
       private:
           Timer                     m_time;
           std::chrono::milliseconds m_till_next = std::chrono::milliseconds(0);
   
           std::vector<AniFrame>           m_frames;
           std::vector<AniFrame>::iterator m_curr_frame = m_frames.begin();
       };
   
       template<template<typename> class... Ex>
       using EAnimation = typename MixBuilder<Animation, Ex...>::type;
   
   } // namespace ctl::sdl
   #endif // !_CTL_SDL2_ANIMATION_
